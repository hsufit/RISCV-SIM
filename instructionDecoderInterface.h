#include <stdint.h>
#include <map>

#include "systemc.h"

#ifndef INC_INSTRUCTION_DECODER_INTERFACE_H_
#define INC_INSTRUCTION_DECODER_INTERFACE_H_
class INSTRUCTION_DECODER_INTERFACE
{
public:
	enum ExtensionType {
		BASE_RV32I,
		UNSUPPORTED,
	};

	enum Opcode {
		IMM_OP = 0b0010011,
		LUI_OP = 0b0110111,
		AUIPC_OP = 0b0010111,
		LOAD_OP = 0b0000011,
		STORE_OP = 0b0100011,
		JAL_OP = 0b1101111,
		JALR_OP = 0b1100111,
		BRANCH_OP = 0b1100011,
		MISC_MEM_OP = 0b0001111,
		SYSTEM_OP = 0b1110011,
		REG_OP = 0b0110011,
	};

	enum Func3 {
		//IMM_OP
		ADDI_FN3 = 0b000,
		ANDI_FN3 = 0b111,
		ORI_FN3 = 0b110,
		XORI_FN3 = 0b100,
		SLTI_FN3 = 0b010,
		SLTIU_FN3 = 0b011,
		SLLI_FN3 = 0b001,
		SRLI_FN3 = 0b101,
		SRAI_FN3 = 0b101,
		LB_FN3 = 0b000,
		LH_FN3 = 0b001,
		LW_FN3 = 0b010,
		LBU_FN3 = 0b100,
		LHU_FN3 = 0b101,
		SB_FN3 = 0b000,
		SH_FN3 = 0b001,
		SW_FN3 = 0b010,
		JALR_FN3 = 0b000,
		BEQ_FN3 = 0b000,
		BNE_FN3 = 0b001,
		BLT_FN3 = 0b100,
		BGE_FN3 = 0b101,
		BLTU_FN3 = 0b110,
		BGEU_FN3 = 0b111,
		FENCE_FN3 = 0b000,
		ADD_FN3 = 0b000,
		SUB_FN3 = 0b000,
		AND_FN3 = 0b111,
		OR_FN3 = 0b110,
		XOR_FN3 = 0b100,
		SLT_FN3 = 0b010,
		SLTU_FN3 = 0b011,
		SLL_FN3 = 0b001,
		SRL_FN3 = 0b101,
		SRA_FN3 = 0b101,
	};

	enum Func7 {
		ADD_FN7 = 0b0000000,
		SUB_FN7 = 0b0100000,
		AND_FN7 = 0b0000000,
		OR_FN7 = 0b0000000,
		XOR_FN7 = 0b0000000,
		SLT_FN7 = 0b0000000,
		SLTU_FN7 = 0b0000000,
		SLL_FN7 = 0b0000000,
		SRL_FN7 = 0b0000000,
		SRA_FN7 = 0b0100000,
	};

	enum Func12 {
		ECALL_FN12 = 0b0,
		EBREAK_FN12 = 0b1,
	};

	enum Instruction {
		ADDI_INSTRUCTION_ENUM,
		ANDI_INSTRUCTION_ENUM,
		ORI_INSTRUCTION_ENUM,
		XORI_INSTRUCTION_ENUM,
		SLTI_INSTRUCTION_ENUM,
		SLTIU_INSTRUCTION_ENUM,
		SLLI_INSTRUCTION_ENUM,
		SRLI_INSTRUCTION_ENUM,
		SRAI_INSTRUCTION_ENUM,
		LUI_INSTRUCTION_ENUM,
		AUIPC_INSTRUCTION_ENUM,
		LB_INSTRUCTION_ENUM,
		LH_INSTRUCTION_ENUM,
		LW_INSTRUCTION_ENUM,
		LBU_INSTRUCTION_ENUM,
		LHU_INSTRUCTION_ENUM,
		SB_INSTRUCTION_ENUM,
		SH_INSTRUCTION_ENUM,
		SW_INSTRUCTION_ENUM,
		JAL_INSTRUCTION_ENUM,
		JALR_INSTRUCTION_ENUM,
		BEQ_INSTRUCTION_ENUM,
		BNE_INSTRUCTION_ENUM,
		BLT_INSTRUCTION_ENUM,
		BGE_INSTRUCTION_ENUM,
		BLTU_INSTRUCTION_ENUM,
		BGEU_INSTRUCTION_ENUM,
		FENCE_INSTRUCTION_ENUM,
		FENCE_TSO_INSTRUCTION_ENUM,
		ECALL_INSTRUCTION_ENUM,
		EBREAK_INSTRUCTION_ENUM,
		ADD_INSTRUCTION_ENUM,
		SUB_INSTRUCTION_ENUM,
		AND_INSTRUCTION_ENUM,
		OR_INSTRUCTION_ENUM,
		XOR_INSTRUCTION_ENUM,
		SLT_INSTRUCTION_ENUM,
		SLTU_INSTRUCTION_ENUM,
		SLL_INSTRUCTION_ENUM,
		SRL_INSTRUCTION_ENUM,
		SRA_INSTRUCTION_ENUM,
		INVALID_INSTRUCTION_ENUM,
	};

	std::map<Instruction, std::string> instruction_name_map = {
		{ADDI_INSTRUCTION_ENUM,"ADDI"},
		{ANDI_INSTRUCTION_ENUM,"ANDI"},
		{ORI_INSTRUCTION_ENUM,"ORI"},
		{XORI_INSTRUCTION_ENUM,"XORI"},
		{SLTI_INSTRUCTION_ENUM,"SLTI"},
		{SLTIU_INSTRUCTION_ENUM,"SLTIU"},
		{SLLI_INSTRUCTION_ENUM,"SLLI"},
		{SRLI_INSTRUCTION_ENUM,"SRLI"},
		{SRAI_INSTRUCTION_ENUM,"SRAI"},
		{LUI_INSTRUCTION_ENUM,"LUI"},
		{AUIPC_INSTRUCTION_ENUM,"AUIPC"},
		{LB_INSTRUCTION_ENUM,"LB"},
		{LH_INSTRUCTION_ENUM,"LH"},
		{LW_INSTRUCTION_ENUM,"LW"},
		{LBU_INSTRUCTION_ENUM,"LBU"},
		{LHU_INSTRUCTION_ENUM,"LHU"},
		{SB_INSTRUCTION_ENUM,"SB"},
		{SH_INSTRUCTION_ENUM,"SH"},
		{SW_INSTRUCTION_ENUM,"SW"},
		{JAL_INSTRUCTION_ENUM,"JAL"},
		{JALR_INSTRUCTION_ENUM,"JALR"},
		{BEQ_INSTRUCTION_ENUM,"BEQ"},
		{BNE_INSTRUCTION_ENUM,"BNE"},
		{BLT_INSTRUCTION_ENUM,"BLT"},
		{BGE_INSTRUCTION_ENUM,"BGE"},
		{BLTU_INSTRUCTION_ENUM,"BLTU"},
		{BGEU_INSTRUCTION_ENUM,"BGEU"},
		{FENCE_INSTRUCTION_ENUM,"FENCE"},
		{FENCE_TSO_INSTRUCTION_ENUM,"FENCE_TSO"},
		{ECALL_INSTRUCTION_ENUM,"ECALL"},
		{EBREAK_INSTRUCTION_ENUM,"EBREAK"},
		{ADD_INSTRUCTION_ENUM,"ADD"},
		{SUB_INSTRUCTION_ENUM,"SUB"},
		{AND_INSTRUCTION_ENUM,"AND"},
		{OR_INSTRUCTION_ENUM,"OR"},
		{XOR_INSTRUCTION_ENUM,"XOR"},
		{SLT_INSTRUCTION_ENUM,"SLT"},
		{SLTU_INSTRUCTION_ENUM,"SLTU"},
		{SLL_INSTRUCTION_ENUM,"SLL"},
		{SRL_INSTRUCTION_ENUM,"SRL"},
		{SRA_INSTRUCTION_ENUM,"SRA"},

	};

	void set_instruction(uint32_t value)
	{
		instruction_value = sc_dt::sc_uint<32>(value);
	}

	INSTRUCTION_DECODER_INTERFACE::ExtensionType extension()
	{
		if ((instruction_value & 0x00000003) == 0b11) {
			return INSTRUCTION_DECODER_INTERFACE::BASE_RV32I;
		}
		return INSTRUCTION_DECODER_INTERFACE::UNSUPPORTED;
	}

	virtual Instruction get_instruction() = 0;
	virtual uint32_t get_opcode() = 0;
	virtual uint32_t get_func3() = 0;
	virtual uint32_t get_func7() = 0;
	virtual uint32_t get_func12() = 0;

	virtual uint32_t get_rs1() = 0;
	virtual uint32_t get_rs2() = 0;
	virtual uint32_t get_rd() = 0;

	virtual int32_t get_imm(uint32_t start, uint32_t end) = 0;
	virtual int32_t get_imm_j() = 0;
	virtual int32_t get_imm_b() = 0;
	virtual uint32_t get_imm_fence_fm() = 0;

protected:
	sc_dt::sc_uint<32> instruction_value;
};

#endif //INC_INSTRUCTION_DECODER_INTERFACE_H_

